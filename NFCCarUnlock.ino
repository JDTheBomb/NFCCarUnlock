/**
 * ----------------------------------------------------------------------------
 * This is a MFRC522 library example; see https://github.com/miguelbalboa/rfid
 * for further details and other examples.
 *
 * NOTE: The library file MFRC522.h has a lot of useful info. Please read it.
 *
 * Released into the public domain.
 * ----------------------------------------------------------------------------
 * This sample shows how to read and write data blocks on a MIFARE Classic PICC
 * (= card/tag).
 *
 * BEWARE: Data will be written to the PICC, in sector #1 (blocks #4 to #7).
 *
 *
 * Typical pin layout used:
 * -----------------------------------------------------------------------------------------
 *             MFRC522      Arduino       Arduino   Arduino    Arduino          Arduino
 *             Reader/PCD   Uno/101       Mega      Nano v3    Leonardo/Micro   Pro Micro
 * Signal      Pin          Pin           Pin       Pin        Pin              Pin
 * -----------------------------------------------------------------------------------------
 * RST/Reset   RST          9             5         D9         RESET/ICSP-5     RST
 * SPI SS      SDA(SS)      10            53        D10        10               10
 * SPI MOSI    MOSI         11 / ICSP-4   51        D11        ICSP-4           16
 * SPI MISO    MISO         12 / ICSP-1   50        D12        ICSP-1           14
 * SPI SCK     SCK          13 / ICSP-3   52        D13        ICSP-3           15
 *
 * More pin layouts for other boards can be found here: https://github.com/miguelbalboa/rfid#pin-layout
 *
 */

#include <SPI.h>
#include <MFRC522.h>

#define RST_PIN         5           // Configurable, see typical pin layout above
#define SS_PIN          53          // Configurable, see typical pin layout above

MFRC522 mfrc522(SS_PIN, RST_PIN);   // Create MFRC522 instance.

MFRC522::MIFARE_Key key;
MFRC522::Uid MyUID = {0x04,0x09,0x53,0x84,0xB3};
byte UID[4] = {0x09,0x53,0x84,0xB3};
MFRC522::MIFARE_Key Keys [32] = {
  {0x96,0x28,0x99,0x94,0x64,0xA1},
  {0xC1,0x74,0xDC,0xE1,0xA5,0xC4},
  {0x3F,0x4F,0x4E,0xF5,0x51,0x72},
  {0x95,0x0C,0xC9,0xA7,0xA4,0xAE},
  {0xAE,0x8C,0xC2,0x81,0xDB,0x44},
  {0x66,0x8E,0x55,0xDF,0x78,0x73},
  {0x14,0x59,0x44,0xCA,0x62,0xB2},
  {0xF5,0x3B,0x30,0xA4,0x80,0x92},
  {0xD1,0xFF,0x9A,0xD5,0xF6,0xF2},
  {0x62,0x4A,0xF7,0x88,0xF7,0x8E},
  {0x3C,0x85,0xBE,0x83,0x9B,0x3A},
  {0xB2,0x1B,0x0F,0x95,0xE9,0x65},
  {0xE0,0x41,0x1B,0x03,0x7B,0x3A},
  {0x7C,0x85,0x7B,0x2D,0xDD,0xEC},
  {0xBE,0xF1,0x91,0x7E,0x21,0x93},
  {0x3F,0x24,0x43,0xBC,0x18,0x28},
  {0xE1,0x82,0xCB,0xB5,0xDB,0xD6},
  {0xC4,0xD5,0x98,0x8D,0xB1,0x85},
  {0xD7,0x67,0xB7,0x8A,0xF2,0xED},
  {0x9F,0x66,0x04,0xFA,0x8A,0x2A},
  {0xE6,0xE4,0x58,0xC1,0xC2,0x17},
  {0xBA,0x7A,0xFE,0x94,0x10,0x8D},
  {0x61,0xF9,0x10,0x03,0xEB,0x35},
  {0x3B,0xC8,0xEE,0x72,0x92,0x3D},
  {0x4C,0x38,0xAE,0x5E,0x88,0x7D},
  {0xA9,0x1B,0x83,0xBA,0xBF,0x03},
  {0x6d,0x7d,0x62,0x52,0x0b,0x3e},
  {0x4b,0xd8,0x3d,0x31,0x86,0xda},
  {0x68,0xc4,0x1e,0x8a,0x19,0x03},
  {0x5e,0x9e,0xbf,0xfa,0x4e,0x15},
  {0xbd,0xef,0xfc,0x3a,0x67,0xa4},
  {0x23,0x25,0x61,0x8f,0x71,0xda}
};
byte BlockData[48][16]={
  {0x09,0x53,0x84,0xB3,0x6D,0x08,0x04,0x00,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69},
  {0xc6,0x0d,0x19,0x86,0x71,0x30,0x34,0xd4,0xbc,0x18,0xd5,0x4a,0x41,0x83,0x4c,0xe6},
  {0xc5,0xc6,0x38,0x87,0x79,0x3f,0x15,0x20,0xaa,0x3a,0xb5,0x25,0x60,0x01,0x97,0x7c},
  {0x14,0xb8,0xdf,0xe4,0x54,0x6f,0x65,0x44,0x5a,0x30,0x0c,0x3b,0x42,0xad,0xb9,0xe6},
  {0xac,0x6d,0x0d,0xdc,0xf8,0x61,0xaa,0x83,0xce,0x9d,0x16,0x43,0x0f,0xf6,0x49,0x8c},
  {0x46,0x09,0xaf,0x5d,0x6e,0xea,0x36,0x2a,0xd3,0xfe,0xa2,0x8a,0xcd,0xf4,0xdb,0xf2},
  {0x7e,0x9b,0x35,0x70,0x9f,0x65,0x4e,0x40,0x45,0x85,0xc2,0xd8,0x24,0xbf,0x96,0xe3},
  {0xc6,0x1a,0x3a,0x01,0x89,0x75,0xf0,0xc3,0xcb,0x10,0x79,0x3c,0x7d,0x8b,0xe6,0x9c},
  {0x08,0xba,0xb5,0xd1,0xe0,0x93,0x21,0x92,0x04,0x4b,0x29,0xd9,0x8d,0x44,0x2b,0xf2},
  {0x8e,0x06,0xf1,0x00,0x93,0xd7,0x4e,0xb8,0x0a,0xc6,0xb0,0x77,0x70,0x1d,0x07,0x32},
  {0xb9,0x9e,0xc8,0xca,0x69,0xcb,0x95,0xad,0x05,0x44,0x28,0x20,0xc1,0x78,0x91,0xe6},
  {0xe1,0xc1,0xfc,0xc3,0xfd,0xb5,0xb4,0x0b,0x87,0x48,0x5e,0xf1,0xd1,0x03,0x55,0x88},
  {0x3b,0x2b,0x7f,0xef,0xb2,0x3b,0x90,0xa1,0xaa,0xfe,0xc5,0xc7,0x98,0x7b,0x30,0x24},
  {0x1f,0x68,0x2c,0xa8,0x3d,0xb2,0x28,0xf7,0x77,0x87,0xd5,0x15,0x0f,0x3c,0xa5,0x9a},
  {0x8f,0xd8,0xb2,0xe2,0xd8,0x83,0x11,0x0e,0x6d,0xdb,0x1b,0xe6,0x02,0xd9,0x09,0x1c},
  {0x53,0x68,0x83,0x6d,0x33,0x2e,0x8b,0xb1,0x22,0xf8,0xc6,0xef,0xa8,0x57,0xd3,0x96},
  {0xce,0x9e,0xfd,0x69,0xfc,0xa0,0x0b,0xce,0xb2,0x97,0xdf,0xda,0xc3,0xa7,0xc9,0xd0},
  {0x06,0xe8,0x2e,0x1c,0x05,0x45,0x2b,0x2a,0x63,0x6c,0x85,0x72,0xb9,0xf5,0xd0,0x92},
  {0x1d,0x02,0xd6,0xb2,0xec,0x40,0x43,0x60,0x8a,0x82,0xd5,0x37,0x7a,0x14,0xe1,0x44},
  {0x69,0xd2,0x9a,0x6a,0xb2,0x7e,0x8e,0xbb,0x97,0x79,0xe9,0xac,0xe5,0x9d,0x07,0xff},
  {0x06,0x72,0x19,0x68,0x6e,0xce,0x00,0x40,0x6c,0xbe,0x45,0x03,0xc7,0xe0,0x97,0x5a},
  {0xa4,0x0c,0xd0,0xcd,0x5a,0x54,0x38,0xfd,0xa3,0xf0,0x7c,0x37,0xbf,0x70,0xa4,0x6b},
  {0x4f,0x18,0x34,0xf5,0x57,0xde,0xfe,0xf2,0x80,0x31,0x49,0xe3,0xc9,0x6e,0x05,0x60},
  {0xc9,0x23,0x74,0x94,0x61,0xe2,0x7d,0x3b,0xce,0x56,0x32,0xb1,0x6a,0x4e,0xd1,0x44},
  {0x1c,0x57,0x23,0x4c,0x1b,0x86,0xef,0xa5,0xda,0xd1,0x32,0xce,0x90,0xcd,0x85,0xe8},
  {0x37,0x4e,0x4b,0x16,0xfd,0xea,0xf0,0xc5,0x3c,0xd3,0xeb,0x67,0x6a,0xbe,0x81,0x97},
  {0xac,0x25,0x76,0xb8,0xcb,0x28,0x9e,0xfd,0x2f,0xc4,0x5b,0xf6,0x7a,0x49,0x89,0xbb},
  {0x34,0xd2,0xfb,0xa1,0xd9,0x7c,0x5d,0x07,0xbc,0x59,0x30,0x15,0xa7,0x91,0x6e,0x11},
  {0x3f,0x20,0x3e,0xab,0xaa,0xba,0x89,0x0b,0xfb,0x2f,0xc6,0xd9,0x97,0x17,0x73,0xad},
  {0xec,0x55,0x13,0xd1,0xd1,0x5f,0x7f,0x60,0x23,0xc1,0x00,0x6b,0xbf,0xa5,0xa6,0xe9},
  {0xdc,0xc6,0x66,0x85,0x87,0x93,0x78,0x93,0x82,0xdb,0x90,0x1d,0xa4,0x2f,0xbe,0x05},
  {0x97,0x3a,0x3d,0x21,0x2c,0x54,0x2c,0x66,0xfe,0xfe,0xb3,0x05,0x05,0xa1,0x62,0x93},
  {0x8a,0x62,0x4b,0x9e,0x20,0xb2,0x2a,0xfb,0x3e,0xa5,0x8a,0x12,0x97,0x87,0x89,0xca},
  {0x23,0x6c,0xf3,0x5b,0xe4,0xc2,0x75,0x92,0xa2,0xda,0xc4,0xfc,0x0a,0x66,0x77,0x14},
  {0x65,0x91,0x19,0x63,0x89,0x57,0x0e,0x39,0x4d,0x3e,0xa4,0x46,0x0d,0x3d,0x8b,0x7b},
  {0x04,0xa3,0x5d,0x3c,0xcf,0x71,0x57,0x96,0x99,0x71,0x3d,0xe1,0xac,0x4a,0x6a,0x98},
  {0x40,0x4c,0x9f,0xee,0x9c,0x39,0xf2,0xbe,0x1b,0x7a,0xc6,0x21,0x33,0x26,0x16,0x69},
  {0x25,0x60,0x47,0x52,0xbe,0x9b,0x42,0xb7,0x0c,0x70,0x45,0x45,0x63,0x47,0xad,0x8e},
  {0x77,0x12,0x86,0x2b,0xfa,0xf7,0xc8,0x8c,0xa8,0x22,0xe3,0x12,0x8d,0x1c,0xfe,0xb6},
  {0x2d,0xa8,0xab,0xe7,0xae,0x73,0x9b,0xbf,0x86,0x8a,0x00,0x5f,0x24,0x4b,0xeb,0xdd},
  {0xb1,0xd6,0xf7,0x94,0x8d,0xc6,0xcf,0xbe,0x6c,0x88,0x6a,0xe4,0x57,0x33,0x4c,0x43},
  {0x63,0xc9,0x67,0xd1,0x59,0x8b,0x8f,0xbc,0xa3,0x85,0x74,0x97,0x16,0x2c,0x5a,0x78},
  {0xa8,0x86,0x97,0x7e,0x0a,0xaa,0x0a,0x9f,0x6b,0x43,0x88,0x30,0x29,0x3e,0x81,0x83},
  {0xd2,0xd5,0x26,0xb6,0x23,0x1b,0xa7,0x7d,0xd4,0x60,0x49,0x86,0x72,0x2f,0x3b,0x07},
  {0xe1,0x3c,0xc1,0x86,0xa5,0xfa,0xc8,0x26,0x96,0x78,0x56,0xdb,0x1d,0xf5,0x90,0x38},
  {0xa1,0xa0,0xae,0x96,0xf0,0x53,0xa6,0x5c,0x33,0xaa,0xd6,0x24,0x44,0xab,0xe1,0x46},
  {0x49,0x49,0x79,0xe5,0xfc,0x62,0x01,0xcd,0x07,0xb8,0x55,0x76,0xfa,0x6a,0xc8,0x63},
  {0x9a,0x50,0x90,0x2a,0x93,0x6f,0xcd,0x8c,0x99,0x32,0x27,0xf2,0xf2,0xd8,0xc8,0x0e}
};



/**
 * Initialize.
 */
void setup() {
    
    Serial.begin(9600); // Initialize serial communications with the PC
    while (!Serial);    // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
    SPI.begin();        // Init SPI bus
    mfrc522.PCD_Init(); // Init MFRC522 card

    // Prepare the key (used both as key A and as key B)
    // using FFFFFFFFFFFFh which is the default at chip delivery from the factory
    for (byte i = 0; i < 6; i++) {
        key.keyByte[i] = 0xFF;
    }
    //Serial.print(F("Using key (for A and B):"));
    //dump_byte_array(key.keyByte, MFRC522::MF_KEY_SIZE);
    randomSeed(analogRead(5));
}

/**
 * Main loop.
 */
void loop() {
    // Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
    if ( ! mfrc522.PICC_IsNewCardPresent())
        return;

    // Select one of the cards
    if ( ! mfrc522.PICC_ReadCardSerial())
        return;

    for(byte i = 0; i < mfrc522.uid.size;i++){
      if(MyUID.uidByte[i] != mfrc522.uid.uidByte[i]){
        return;
      }
    }

    if (mfrc522.PICC_GetType(mfrc522.uid.sak) != MFRC522::PICC_TYPE_MIFARE_1K) {
        Serial.println(F("This sample only works with MIFARE Classic cards."));
        return;
    }

    // In this sample we use the second sector,
    // that is: sector #1, covering block #4 up to and including block #7
    byte KeyChoice = random(15);
    MFRC522::StatusCode status;
    byte buffer[18];
    byte size = sizeof(buffer);


    // Authenticate using key A
    status = (MFRC522::StatusCode) mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, KeyChoice*4, &Keys[KeyChoice*2], &(mfrc522.uid));
    if (status != MFRC522::STATUS_OK) {
        Serial.print(F("PCD_Authenticate() failed: "));
        Serial.println(mfrc522.GetStatusCodeName(status));
        return;
    }

    // Read data from the block
    for(byte i=KeyChoice*4;i<(KeyChoice*4);i++){
      Serial.print("Letter I: ");
      Serial.println(i);
      
      status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(i, buffer, &size);
      if (status != MFRC522::STATUS_OK) {
          Serial.print(F("MIFARE_Read() failed: "));
          Serial.println(mfrc522.GetStatusCodeName(status));
      }

      Serial.print(F("Data in block")); Serial.println(F(":"));
      dump_byte_array(buffer, 16); Serial.println();

      for(byte j=0;j<16;j++){
        Serial.print("KeyChoice: ");
        Serial.println(KeyChoice*4);
        dump_byte_array(BlockData[(KeyChoice*4)+i],16);
        if(BlockData[(KeyChoice*4)+i][j]!=buffer[j]){
          Serial.println("Test");
          return;
        }
      }
    }
    Serial.println("Verified");
    // Halt PICC
    mfrc522.PICC_HaltA();
    // Stop encryption on PCD
    mfrc522.PCD_StopCrypto1();
}

/**
 * Helper routine to dump a byte array as hex values to Serial.
 */
void dump_byte_array(byte *buffer, byte bufferSize) {
    for (byte i = 0; i < bufferSize; i++) {
        Serial.print(buffer[i] < 0x10 ? " 0" : " ");
        Serial.print(buffer[i], HEX);
    }
}
